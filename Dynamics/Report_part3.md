# Part 3: Dynamics Simulation of a 7-DOF Robotic Manipulator

## Overview
This part involves simulating the dynamics of a 7-DOF robotic manipulator using Simulink. The simulation models the manipulator's motion under zero applied torques, allowing it to move under gravity and its own dynamics.

## Simulink Model Description
The Simulink model (`Simulation.slx`) implements the following components:

### Inputs
- **Torques**: Generated by `Applied_Torque.m`. All torques are set to zero (`Tau = zeros(7,1)`), simulating an uncontrolled system.

### Dynamics Computation
- **Mass Matrix (`M(q)`)**: Computed by `MassMatrix.m`, which calculates the 7x7 mass matrix using the manipulator's inertial parameters and DH parameters.
- **Nonlinear Terms (`N(q, qd)`)**: Computed by `NEquation.m` using the Newton-Euler recursive algorithm. This includes Coriolis, centrifugal, and gravity effects.
- **Dynamic Model**: The `Dynamic_model.m` function computes the state derivatives using:
  \[
  M(q) \ddot{q} + N(q, \dot{q}) = \tau
  \]
  where `tau = 0`. The joint accelerations are:
  \[
  \ddot{q} = M(q)^{-1} (\tau - N(q, \dot{q}))
  \]
  The state derivatives are `state_d = [qd; qdd]`.

### Integration
- An `Integrator` block integrates `state_d` to produce the state `state = [q; qd]`, where `q` is the 7x1 vector of joint positions, and `qd` is the 7x1 vector of joint velocities.

### Outputs
- **Torques1**: The applied torques (zero in this case).
- **q**: Joint positions, extracted using `fcn.m`.
- **state**: The full state vector `[q; qd]`.
- **pos**: End-effector position `[x; y; z]`, computed by `Frame_origin.m`.
- **join_px, join_py, join_pz**: Joint positions in Cartesian coordinates, also from `Frame_origin.m`.